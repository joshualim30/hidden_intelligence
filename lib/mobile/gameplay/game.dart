// game.dart
// Game - Game logic, this will be the main class that will be used to interact with the game

// HOW THE GAME WORKS:
// - The game will be played in a series of rounds
// - Each round will have a different prompt... a prompt will be something theorhetical like "What would you do if you were the last person on earth?"
// - Each player will have to submit a response to the prompt
// - The AI will then read the prompt and responses to the prompt, and generate a response that blends in with the player responses
// - The players will then have to guess which response was generated by the AI
// - Players will earn points for guessing correctly, and the AI will earn points for fooling the players
// - The game will end after a certain number of rounds, and the player with the most points will win

import 'dart:math';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_dotenv/flutter_dotenv.dart';
import 'package:hidden_intelligence/mobile/gameplay/waiting_room.dart';
import 'package:google_generative_ai/google_generative_ai.dart';

// Game Screen
class GameScreen extends StatefulWidget {
  const GameScreen({
    super.key,
    required this.gameId,
    required this.player,
  });

  final String gameId;
  final Player player;

  @override
  State<GameScreen> createState() => _GameScreenState();
}

class _GameScreenState extends State<GameScreen> {
  // Variables
  bool isLoading = false;
  String prompt = 'Loading...';
  String response = '';
  Round currentRound = Round(
    prompt: '',
    responses: [],
    aiResponse: '',
    votes: [],
  );
  Game currentGame = Game(
    gameId: '',
    status: 'in_progress',
    players: [],
    rounds: [],
    aiPoints: 0,
  );

  @override
  Widget build(BuildContext context) {
    return StreamBuilder<DocumentSnapshot>(
      stream: FirebaseFirestore.instance
          .collection('games')
          .doc(widget.gameId)
          .snapshots(),
      builder: (context, snapshot) {
        if (snapshot.hasData) {
          currentGame = Game(
            gameId: snapshot.data!.id,
            status: snapshot.data!['status'],
            players: snapshot.data!['players']
                .map<Player>((player) => Player.fromJson(player))
                .toList(),
            rounds: snapshot.data!['rounds']
                .map<Round>((round) => Round.fromJson(round))
                .toList(),
            aiPoints: snapshot.data!['aiPoints'],
          );
          // If rounds is empty, create a new round
          if (currentGame.rounds.isEmpty) {
            currentGame.rounds = [
              Round(
                prompt: '',
                responses: [],
                aiResponse: '',
                votes: [],
              ),
            ];
            // Update the game
            FirebaseFirestore.instance
                .collection('games')
                .doc(widget.gameId)
                .update({
              'rounds':
                  currentGame.rounds.map((round) => round.toJson()).toList(),
            });
          }
          return currentGame.rounds.isEmpty ||
                  currentGame.rounds.last.prompt.isEmpty ||
                  currentGame.rounds.last.responses.length <
                          currentGame.players.length &&
                      currentGame.rounds.last.aiResponse.isEmpty
              ? PromptScreen(
                  gameId: widget.gameId,
                  player: widget.player,
                  currentGame: currentGame,
                )
              : currentGame.rounds.last.votes.length <
                          currentGame.players.length &&
                      currentGame.rounds.last.aiResponse.isNotEmpty
                  ? ResponsesScreen(
                      gameId: widget.gameId,
                      player: widget.player,
                      currentGame: currentGame,
                    )
                  : SummaryScreen(
                      gameId: widget.gameId,
                      player: widget.player,
                      currentGame: currentGame,
                    );
        } else {
          return const Center(
            child: CircularProgressIndicator(),
          );
        }
      },
    );
  }
}

// MARK: Prompt Screen
class PromptScreen extends StatefulWidget {
  PromptScreen({
    super.key,
    required this.gameId,
    required this.player,
    required this.currentGame,
  });

  final String gameId;
  final Player player;
  Game currentGame;

  @override
  State<PromptScreen> createState() => _PromptScreenState();
}

class _PromptScreenState extends State<PromptScreen> {
  // Variables
  TextEditingController responseController = TextEditingController();

  // Init State
  @override
  void initState() {
    super.initState();
    // If host, generate a prompt
    if (widget.player.isHost) {
      // Generate a prompt
      _generatePrompt().then((value) {
        debugPrint('Prompt: $value');
        // Update last round with prompt
        if (widget.currentGame.rounds.last.prompt.isEmpty) {
          widget.currentGame.rounds.last.prompt = value;
          // Update the game
          FirebaseFirestore.instance
              .collection('games')
              .doc(widget.gameId)
              .update({
            'rounds': widget.currentGame.rounds
                .map((round) => round.toJson())
                .toList(),
          });
        }
      });
    }
  }

  // MARK: Generate Prompt
  // (read in txt file resources/prompts.txt)
  Future<String> _generatePrompt() async {
    // Read in the prompts file
    final String prompts =
        await rootBundle.loadString('lib/resources/prompts.txt');
    // Split the prompts into a list
    final List<String> promptList = prompts.split('\n');
    // Get a random prompt
    final String prompt = promptList[Random().nextInt(promptList.length)];
    // Check if the prompt is valid (not in a past round)
    for (Round round in widget.currentGame.rounds) {
      if (round.prompt == prompt) {
        // Generate a new prompt
        return _generatePrompt();
      }
    }
    // Return the prompt
    return prompt;
  }

  // MARK: Submit Response
  Future<void> _submitResponse(String response) async {
    // Check if the response is valid
    if (response.isEmpty) {
      // Show an error
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Response cannot be empty'),
        ),
      );
      return;
    }
    // // Set loading state
    // setState(() {
    //   isLoading = true;
    // });
    // Get the current round
    final Round round = widget.currentGame.rounds.last;
    // Add the response to the round
    round.responses.add(Response(
      playerID: widget.player.deviceId,
      response: response,
    ));
    // If last player, generate AI response
    if (round.responses.length == widget.currentGame.players.length) {
      // Generate AI Response
      _getResponse(round.prompt).then(
        (value) {
          // Update the current round with the AI response
          round.aiResponse = value;
          // Update the game
          FirebaseFirestore.instance
              .collection('games')
              .doc(widget.gameId)
              .update({
            'rounds': widget.currentGame.rounds
                .map((round) => round.toJson())
                .toList(),
          });
        },
      );
    } else {
      // Update the game
      FirebaseFirestore.instance.collection('games').doc(widget.gameId).update({
        'rounds':
            widget.currentGame.rounds.map((round) => round.toJson()).toList(),
      });
    }
  }

  // MARK: Generate AI Response
  Future<String> _getResponse(String prompt) async {
    // Create the model
    final model = GenerativeModel(
      model: 'gemini-1.5-flash',
      apiKey: dotenv.env['GEMINI_API_KEY'] ?? '',
    );

    // Identity Prompt
    String aiPrompt = 'You are an AI chatbot that is in a game called "Hidden Intelligence". In order to win, you must blend in with human responses. You will be provided with a prompt and human responses, and you must generate a response that fits in with the human responses. Do not ramble or provide irrelevant information, and do not speak perfect English. Use human-like tactics such as typos, grammar mistakes, humor, undercasings, etc, depending on the context. For example, if a prompt is "What would you do if you were the last person on earth?", a human response might be "I would go to the zoo and free all the animals", or "What are three things you would bring to a deserted island?", only list three things such as "boat, map, friend".';
  
    // Context Prompt
    String contextPrompt = 'The prompt for the current round is: "$prompt".';
    contextPrompt = "And the human responses are: ${widget.currentGame.rounds.last.responses.map((response) => response.response).join(', ')}.";

    // Returnable Prompt
    String returnablePrompt = 'Please provide a response that fits in with the human responses, and only respond to the prompt. Do not prefix your response with "I am an AI", "I would...", "I think...", etc.';
    
    // Generate the content
    try {
      final response = await model.generateContent([Content.text(aiPrompt), Content.text(contextPrompt), Content.text(returnablePrompt)]);
      // Remove any newlines
      return response.text?.replaceAll('\n', '') ?? '*Failed to get response*';
    } catch (e) {
      return '*Failed to get response*';
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('Round ${widget.currentGame.rounds.length}'),
      ),
      body: StreamBuilder<DocumentSnapshot>(
        stream: FirebaseFirestore.instance
            .collection('games')
            .doc(widget.gameId)
            .snapshots(),
        builder: (context, snapshot) {
          if (snapshot.hasData) {
            // Update the current game
            widget.currentGame = Game(
              gameId: snapshot.data!.id,
              status: snapshot.data!['status'],
              players: snapshot.data!['players']
                  .map<Player>((player) => Player.fromJson(player))
                  .toList(),
              rounds: snapshot.data!['rounds']
                  .map<Round>((round) => Round.fromJson(round))
                  .toList(),
              aiPoints: snapshot.data!['aiPoints'],
            );
            // If the player has already submitted a response, show a loading indicator
            if (widget.currentGame.rounds.last.responses
                .where(
                    (response) => response.playerID == widget.player.deviceId)
                .isNotEmpty) {
              return Center(
                child: Column(
                  children: [
                    const Padding(
                      padding: EdgeInsets.all(8.0),
                      child: CircularProgressIndicator(),
                    ),
                    const Padding(
                      padding: EdgeInsets.all(8.0),
                      child: Text(
                          'Waiting for other players to submit their responses...'),
                    ),
                    Padding(
                      padding: const EdgeInsets.all(8.0),
                      child: Text(
                          '${widget.currentGame.rounds.last.responses.length} / ${widget.currentGame.players.length}'),
                    ),
                  ],
                ),
              );
            }
            // If everyone has submitted a response, generate an AI response (HOST ONLY)
            if (widget.currentGame.rounds.last.responses.length ==
                    widget.currentGame.players.length &&
                widget.player.isHost) {
              // Generate AI Response
              _getResponse(widget.currentGame.rounds.last.prompt).then(
                (value) {
                  // Update the current round with the AI response
                  widget.currentGame.rounds.last.aiResponse = value;
                  // Update the game
                  FirebaseFirestore.instance
                      .collection('games')
                      .doc(widget.gameId)
                      .update({
                    'rounds': widget.currentGame.rounds
                        .map((round) => round.toJson())
                        .toList(),
                  });
                },
              );
            }
            return Column(
              children: [
                // Prompt
                Padding(
                  padding: const EdgeInsets.all(8.0),
                  child: Text(
                    'Prompt: ${widget.currentGame.rounds.last.prompt}',
                    style: const TextStyle(
                      fontSize: 20,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                ),
                // Submit Response
                if (widget.currentGame.rounds.isNotEmpty &&
                    widget.currentGame.rounds.last.responses
                        .where((response) =>
                            response.playerID == widget.player.deviceId)
                        .isEmpty) ...[
                  Padding(
                    padding: const EdgeInsets.all(8.0),
                    child: TextField(
                      controller: responseController,
                      decoration: const InputDecoration(
                        labelText: 'Response',
                      ),
                      onSubmitted: (response) {
                        _submitResponse(responseController.text);
                      },
                    ),
                  ),
                  Padding(
                    padding: const EdgeInsets.all(8.0),
                    child: ElevatedButton(
                      onPressed: () {
                        _submitResponse(responseController.text);
                      },
                      child: const Text('Submit Response'),
                    ),
                  ),
                ],
              ],
            );
          } else {
            return const Center(
              child: CircularProgressIndicator(),
            );
          }
        },
      ),
    );
  }
}

// MARK: Responses Screen
class ResponsesScreen extends StatefulWidget {
  ResponsesScreen({
    super.key,
    required this.gameId,
    required this.player,
    required this.currentGame,
  });

  final String gameId;
  final Player player;
  Game currentGame;

  @override
  State<ResponsesScreen> createState() => _ResponsesScreenState();
}

class _ResponsesScreenState extends State<ResponsesScreen> {
  List<Response> responses = [];
  int guessed = 0;

  // MARK: Guess AI Response
  Future<void> _guessAIResponse(String guess) async {
    // Check if the response is valid
    if (guess.isEmpty) {
      // Show an error
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Response cannot be empty'),
        ),
      );
      return;
    }
    // // Set loading state
    // setState(() {
    //   isLoading = true;
    // });
    // Get the current round
    final Round round = widget.currentGame.rounds.last;
    String id;
    // Check if the response is correct
    if (round.aiResponse == guess) {
      // Add points to the player
      widget.player.points += 3; // TODO: Make point system dynamic
      widget.currentGame.players[widget.currentGame.players.indexWhere(
              (player) => player.deviceId == widget.player.deviceId)] =
          widget.player;
      id = "AI";
      // Set guessed state
      setState(() {
        guessed = 1;
      });
    } else {
      // Add points to the AI
      widget.currentGame.aiPoints += 1; // TODO: Make point system dynamic
      id = round.responses
          .firstWhere((response) => response.response == guess)
          .playerID;
      // Set guessed state
      setState(() {
        guessed = 2;
      });
    }
    // See if vote for response already exists
    Vote existingVote = round.votes.firstWhere(
      (vote) => vote.playerID == widget.player.deviceId,
      orElse: () => Vote(playerID: id, votes: []),
    );
    // Add vote to the round
    if (existingVote.votes.isEmpty) {
      existingVote.votes.add(widget.player.deviceId);
      round.votes.add(existingVote);
    } else {
      existingVote.votes.add(widget.player.deviceId);
    }
    // Update the game
    FirebaseFirestore.instance.collection('games').doc(widget.gameId).update(
          widget.currentGame.toJson(),
        );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Responses'),
      ),
      body: guessed == 0
          ? StreamBuilder<DocumentSnapshot>(
              stream: FirebaseFirestore.instance
                  .collection('games')
                  .doc(widget.gameId)
                  .snapshots(),
              builder: (context, snapshot) {
                if (snapshot.hasData) {
                  // Update the current game
                  widget.currentGame = Game(
                    gameId: snapshot.data!.id,
                    status: snapshot.data!['status'],
                    players: snapshot.data!['players']
                        .map<Player>((player) => Player.fromJson(player))
                        .toList(),
                    rounds: snapshot.data!['rounds']
                        .map<Round>((round) => Round.fromJson(round))
                        .toList(),
                    aiPoints: snapshot.data!['aiPoints'],
                  );

                  // Append AI response to responses, and shuffle
                  responses = [
                    ...widget.currentGame.rounds.last.responses,
                    Response(
                      playerID: 'AI',
                      response: widget.currentGame.rounds.last.aiResponse,
                    ),
                  ];
                  responses.shuffle();

                  // If the player has already submitted a response, show a loading indicator
                  if (widget.currentGame.rounds.last.votes
                      .where((vote) => vote.playerID == widget.player.deviceId)
                      .isNotEmpty) {
                    return Center(
                      child: Column(
                        children: [
                          const Padding(
                            padding: EdgeInsets.all(8.0),
                            child: CircularProgressIndicator(),
                          ),
                          const Padding(
                            padding: EdgeInsets.all(8.0),
                            child: Text(
                                'Waiting for other players to submit their votes...'),
                          ),
                          Padding(
                            padding: const EdgeInsets.all(8.0),
                            child: Text(
                                '${widget.currentGame.rounds.last.votes.length} / ${widget.currentGame.players.length}'),
                          ),
                        ],
                      ),
                    );
                  }
                  return Column(
                    children: [
                      // Prompt
                      Padding(
                        padding: const EdgeInsets.all(8.0),
                        child: Text(
                          'Prompt: ${widget.currentGame.rounds.last.prompt}',
                          style: const TextStyle(
                            fontSize: 20,
                            fontWeight: FontWeight.bold,
                          ),
                        ),
                      ),
                      // Responses
                      for (Response response in responses) ...[
                        Padding(
                          padding: const EdgeInsets.all(8.0),
                          child: Card(
                            child: ListTile(
                              title: Text(response.response),
                              onTap: () {
                                _guessAIResponse(response.response);
                              },
                            ),
                          ),
                        ),
                      ],
                    ],
                  );
                } else {
                  return const Center(
                    child: CircularProgressIndicator(),
                  );
                }
              },
            )
          : Center(
            child: Column(
                children: [
                  Padding(
                    padding: const EdgeInsets.all(8.0),
                    child: Text(
                      guessed == 1
                          ? 'You guessed correctly! +2 points'
                          : 'You guessed incorrectly! +1 point to AI',
                      style: const TextStyle(
                        fontSize: 20,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                  ),
                  const Text("Waiting for other players to guess..."),
                  Text(
                      "${widget.currentGame.rounds.last.votes.length}/${widget.currentGame.players.length}"),
                ],
              ),
          ),
    );
  }
}

// MARK: Round Summary Screen
class SummaryScreen extends StatefulWidget {
  SummaryScreen({
    super.key,
    required this.gameId,
    required this.player,
    required this.currentGame,
  });

  final String gameId;
  final Player player;
  Game currentGame;

  @override
  State<SummaryScreen> createState() => _SummaryScreenState();
}

class _SummaryScreenState extends State<SummaryScreen> {
  // Variables
  List<Response> responses = [];

  // MARK: Init State
  @override
  void initState() {
    super.initState();
    // Append AI response to responses
    responses = [
      ...widget.currentGame.rounds.last.responses,
      Response(
        playerID: 'AI',
        response: widget.currentGame.rounds.last.aiResponse,
      ),
    ];
    responses.sort((a, b) => a.playerID == 'AI' ? 1 : -1);
  }

  // MARK: Next Round
  Future<void> _nextRound() async {
    // Create a new round
    widget.currentGame.rounds = [
      ...widget.currentGame.rounds,
      Round(
        prompt: '',
        responses: [],
        aiResponse: '',
        votes: [],
      ),
    ];
    // Update the game
    await FirebaseFirestore.instance
        .collection('games')
        .doc(widget.gameId)
        .update({
      'rounds':
          widget.currentGame.rounds.map((round) => round.toJson()).toList(),
    });
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('Round ${widget.currentGame.rounds.length} Summary'),
      ),
      body: StreamBuilder<DocumentSnapshot>(
        stream: FirebaseFirestore.instance
            .collection('games')
            .doc(widget.gameId)
            .snapshots(),
        builder: (context, snapshot) {
          if (snapshot.hasData) {
            // Update the current game
            widget.currentGame = Game(
              gameId: snapshot.data!.id,
              status: snapshot.data!['status'],
              players: snapshot.data!['players']
                  .map<Player>((player) => Player.fromJson(player))
                  .toList(),
              rounds: snapshot.data!['rounds']
                  .map<Round>((round) => Round.fromJson(round))
                  .toList(),
              aiPoints: snapshot.data!['aiPoints'],
            );
            return ListView(
              children: [
                // Prompt
                Padding(
                  padding: const EdgeInsets.all(8.0),
                  child: Text(
                    'Prompt: ${widget.currentGame.rounds.last.prompt}',
                    style: const TextStyle(
                      fontSize: 20,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                ),
                // Responses
                for (Response response in responses) ...[
                  Padding(
                    padding: const EdgeInsets.all(8.0),
                    child: Card(
                      child: response.playerID == "AI"
                          ? ListTile(
                              leading: Text("🤖"),
                              title: const Text("AI"),
                              subtitle: Text(response.response),
                              trailing:
                                  Text("${widget.currentGame.aiPoints} pts"),
                            )
                          : ListTile(
                              leading: Text(widget.currentGame.players
                                  .firstWhere((player) =>
                                      player.deviceId == response.playerID)
                                  .emoji),
                              title: Text(widget.currentGame.players
                                  .firstWhere((player) =>
                                      player.deviceId == response.playerID)
                                  .username),
                              subtitle: Text(response.response),
                              trailing: Text(
                                  "${widget.currentGame.players.firstWhere((player) => player.deviceId == response.playerID).points} pts"),
                            ),
                    ),
                  ),
                ],
                // Next Round
                Padding(
                  padding: const EdgeInsets.all(8.0),
                  child: ElevatedButton(
                    onPressed: widget.player.isHost ? _nextRound : null,
                    child: widget.player.isHost
                        ? const Text('Next Round')
                        : const Text('Waiting for host to start next round...'),
                  ),
                ),
              ],
            );
          } else {
            return const Center(
              child: CircularProgressIndicator(),
            );
          }
        },
      ),
    );
  }
}
